### 函数表达式

##### 函数声明提升：在执行代码前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面
	sayHi();
	function sayHi() {
		console.log('hi');
	}

##### 递归：函数通过名字调用自身
    //斐波那契数列
    function fibonacci(n) {
        return n < 2 ? n :arguments.callee(n-2) + arguments.callee(n-1);
    }
    fibonacci(30);
>使用arguments.callee()可以代替函数名，但是在严格模式下是不能访问arguments.callee()的，所以要使用命名函数表达式:
    var fibonacci = (function f(n) {
        return n < 2? n : f(n-2) + f(n-1);
    })

##### 闭包：有权访问另一个作用域中的变量的函数
* 在创建一个函数的时候，会创建一个预先包含全局变量对象的作用域链，它被保存在函数内部的[Scope]属性中。当调用函数的时候，会为函数创建一个执行环境，然后通过复制函数的[Scope]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并推入执行环境作用域链的前端。
* 一般来讲，当函数执行完毕后，局部的活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同：
* 当包含闭包的函数执行完毕后，其执行环境的作用域链会被销毁，但它的活动对象仍留在内存中；直到匿名函数被销毁，它的活动对象才会被销毁。
* 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度的使用闭包可能会导致内存占用过多，所以要慎重使用闭包
